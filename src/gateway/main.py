from __future__ import annotations

from contextlib import asynccontextmanager
from typing import AsyncGenerator

from fastapi import FastAPI
from fastapi.exceptions import RequestValidationError
from fastapi.openapi.docs import get_swagger_ui_html
from starlette.exceptions import HTTPException as StarletteHTTPException

from gateway.errors.exceptions import FundboxAPIException
from gateway.errors.handlers import (
    fundbox_exception_handler,
    http_exception_handler,
    validation_exception_handler,
)
from gateway.middleware.db.db_session import db_session_middleware
from gateway.oauth2.token_router import router as token_router
from gateway.routers.debug import router as debug_router
from gateway.routers.leads import router as leads_router
import os
import sys
from gateway.partners.router import mount_partner_docs
from gateway.partners.policies import POLICY_PROVIDER
from gateway.proxy.client import proxy_client_lifespan
from gateway.proxy.router import router as proxy_router


@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    """Lifespan context manager for FastAPI app."""
    # Initialize proxy client (loads canary config and debug mode once)
    async with proxy_client_lifespan() as _:
        yield


ROOT_PATH = os.getenv("GATEWAY_ROOT_PATH", "")

app = FastAPI(
        title="API Gateway",
        description="OAuth2 Gateway API using FastAPI",
        version="0.1.0",
        lifespan=lifespan,
        root_path=ROOT_PATH,
        docs_url=None,  # Custom endpoint below
        redoc_url=None,
        openapi_url="/openapi.json",
)

_disable_db_mw = os.getenv("DISABLE_DB_MIDDLEWARE", "").lower() in {"1", "true", "yes"}
if not _disable_db_mw:
    app.middleware("http")(db_session_middleware)

app.add_exception_handler(FundboxAPIException, fundbox_exception_handler)
app.add_exception_handler(StarletteHTTPException, http_exception_handler)
app.add_exception_handler(RequestValidationError, validation_exception_handler)


# Custom Swagger UI with expanded sections by default
@app.get("/docs", include_in_schema=False)
async def custom_swagger_ui_html():
    return get_swagger_ui_html(
        openapi_url=app.openapi_url,
        title=app.title + " - Swagger UI",
        swagger_ui_parameters={
            "persistAuthorization": True,
            "docExpansion": "full",  # Expand all tags and operations by default
            "defaultModelsExpandDepth": 1,
            "filter": "",  # Show all endpoints (no filter)
            "displayRequestDuration": True,
        },
    )


app.include_router(debug_router)

app.include_router(leads_router, tags=["Leads"])
app.include_router(token_router, tags=["tokens"])

mount_partner_docs(app, POLICY_PROVIDER)


@app.get("/health")
async def health():
    return {"status": "ok"}


@app.get("/")
async def root():
    return {
        "name": "API Gateway",
        "version": "0.1.0",
        "docs": "/docs",
    }


@app.get("/debug/routes")
async def debug_routes():
    """Debug endpoint to list all registered routes."""
    routes = []
    legacy_routes = []
    for route in app.routes:
        if hasattr(route, "path") and hasattr(route, "methods"):
            route_info = {
                "path": route.path,
                "methods": list(route.methods),
                "name": getattr(route, "name", None),
            }
            routes.append(route_info)
            # Check if it's a legacy route (has "Legacy:" tag or path matches legacy patterns)
            if hasattr(route, "tags") and route.tags:
                for tag in route.tags:
                    if tag.startswith("Legacy:"):
                        legacy_routes.append(route_info)
                        break
    return {
        "total_routes": len(routes),
        "legacy_routes_count": len(legacy_routes),
        "routes": routes,
        "legacy_routes": legacy_routes,
    }


# Auto-generated legacy routers (contract-first proxies to Flask)
# Generated by: python legacy/scripts/generate_fastapi_routers.py
try:
    from gateway.routers.legacy import all_routers as legacy_routers
    # Include all legacy routers
    router_count = 0
    for router in legacy_routers:
        app.include_router(router)
        router_count += 1
    if router_count > 0:
        print(f"âœ“ Loaded {router_count} legacy router modules", file=sys.stderr)
    else:
        print("WARNING: No legacy routers found in all_routers", file=sys.stderr)
except ImportError as e:
    # Legacy routers not generated yet or import error
    print(f"WARNING: Could not load legacy routers: {e}", file=sys.stderr)
    import traceback
    traceback.print_exc(file=sys.stderr)
except Exception as e:
    print(f"ERROR: Failed to load legacy routers: {e}", file=sys.stderr)
    import traceback
    traceback.print_exc(file=sys.stderr)


# Register proxy router LAST as fallback for undefined routes
# This catch-all route handles requests not matched by explicitly defined routes above
# As endpoints are migrated to contract-first definitions, fewer requests will hit this fallback
app.include_router(proxy_router)
